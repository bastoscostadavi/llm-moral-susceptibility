#!/usr/bin/env python3
"""Generate LaTeX tables summarizing MFQ moral foundation profiles for models and personas."""

from __future__ import annotations

import argparse
from pathlib import Path
from random import Random
from typing import Dict, Iterable, Tuple

from plot_relevance_profiles import (
    FOUNDATION_ORDER as SELF_FOUNDATIONS,
    load_relevance_scores,
    summarise_scores,
)
from plot_persona_relevance_profiles import (
    FOUNDATION_ORDER as PERSONA_FOUNDATIONS,
    available_personas,
    load_persona_scores,
    summarise_persona_scores,
)

SELF_TABLE_PATH = Path("articles") / "table_moral_foundations_profiles.tex"
PERSONA_TABLE_PATH = Path("articles") / "table_persona_moral_foundations_profiles.tex"
DEFAULT_PERSONA_SAMPLE_SIZE = 14
DEFAULT_PERSONA_SEED = 3


def format_entry(mean: float, se: float) -> str:
    return f"${mean:.2f}\\pm{se:.2f}$"


def write_tabular(
    output_path: Path,
    headers: Iterable[str],
    rows: Iterable[Tuple[str, Iterable[str]]],
) -> None:
    output_path.parent.mkdir(parents=True, exist_ok=True)
    header_cells = " & ".join(headers)
    col_spec = "l" + "c" * (len(headers) - 1)
    lines = [
        "% Auto-generated by analysis/generate_relevance_profile_tables.py",
        f"\\begin{{tabular}}{{{col_spec}}}",
        f"  {header_cells} \\",
        "  \\hline",
    ]
    for row_label, row_entries in rows:
        row_str = " & ".join((row_label, *row_entries))
        lines.append(f"  {row_str} \\")
    lines.append("  \\hline")
    lines.append("\\end{tabular}")
    output_path.write_text("\n".join(lines) + "\n", encoding="utf-8")


def generate_self_table(output_path: Path) -> None:
    scores_by_model = load_relevance_scores()
    summaries = summarise_scores(scores_by_model)
    headers = ["Model", *SELF_FOUNDATIONS]
    rows = []
    for model in sorted(summaries):
        entries = [format_entry(*summaries[model][foundation]) for foundation in SELF_FOUNDATIONS]
        rows.append((model.replace("openrouter-", ""), entries))
    # aggregate across models (self averaged profile)
    if summaries:
        aggregated = {}
        for foundation in SELF_FOUNDATIONS:
            means = []
            ses = []
            for model_summary in summaries.values():
                mean_val, se_val = model_summary[foundation]
                means.append(mean_val)
                ses.append(se_val)
            mean_avg = sum(means) / len(means)
            se_combined = (sum(se ** 2 for se in ses) ** 0.5) / len(ses)
            aggregated[foundation] = (mean_avg, se_combined)
        rows.append(("Average (self)", [format_entry(*aggregated[f]) for f in SELF_FOUNDATIONS]))
    write_tabular(output_path, headers=headers, rows=rows)


def sample_personas(sample_size: int, seed: int | None) -> Tuple[Iterable[int], Dict[int, Dict[str, Tuple[float, float]]]]:
    persona_ids = available_personas()
    if sample_size > len(persona_ids):
        raise ValueError(
            f"Sample size {sample_size} exceeds available personas ({len(persona_ids)})."
        )
    rng = Random(seed)
    selected = sorted(rng.sample(persona_ids, sample_size))
    scores = load_persona_scores(set(selected))
    summaries = summarise_persona_scores(scores)
    return selected, summaries


def generate_persona_table(output_path: Path, sample_size: int, seed: int | None) -> None:
    persona_ids, summaries = sample_personas(sample_size, seed)
    headers = ["Persona", *PERSONA_FOUNDATIONS]
    rows = []
    for persona in persona_ids:
        if persona not in summaries:
            continue
        entries = [
            format_entry(*summaries[persona][foundation])
            for foundation in PERSONA_FOUNDATIONS
        ]
        rows.append((str(persona), entries))
    if not rows:
        raise ValueError("No personas with complete data were selected for table generation.")
    write_tabular(output_path, headers=headers, rows=rows)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description=__doc__)
    parser.add_argument(
        "--self-output",
        type=Path,
        default=SELF_TABLE_PATH,
        help=f"Path for the self-assessment table (default: {SELF_TABLE_PATH})",
    )
    parser.add_argument(
        "--persona-output",
        type=Path,
        default=PERSONA_TABLE_PATH,
        help=f"Path for the persona table (default: {PERSONA_TABLE_PATH})",
    )
    parser.add_argument(
        "--persona-sample-size",
        type=int,
        default=DEFAULT_PERSONA_SAMPLE_SIZE,
        help="Number of personas to include in the persona table (default: %(default)s)",
    )
    parser.add_argument(
        "--persona-seed",
        type=int,
        default=DEFAULT_PERSONA_SEED,
        help="Random seed controlling persona selection (default: %(default)s)",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    generate_self_table(args.self_output)
    generate_persona_table(
        args.persona_output,
        sample_size=args.persona_sample_size,
        seed=args.persona_seed,
    )


if __name__ == "__main__":
    main()
